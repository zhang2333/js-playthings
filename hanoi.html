<!DOCTYPE html>
<html>

<head>
	<meta charset="UTF-8">
	<title>hanoi</title>
	<style>
		#main {
			width: 100%;
			margin: 0px;
			padding: 0px;
			overflow: hidden;
		}
	</style>
</head>

<body>
	<div id="main"></div>

	<script type="text/javascript" src="js/three.min.js"></script>
	<script type="text/javascript" src="js/stats.min.js"></script>
	<script type="text/javascript" src="js/dat.gui.min.js"></script>
	<script type="text/javascript" src="js/OrbitControls.js"></script>
	<script type="text/javascript" src="js/Detector.js"></script>

	<script>
		if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
		
		accurate();
		var scene, camera, renderer, stats, controls;
		var light;
		
		var v = 10;
		var steps = [];
		var poles = [];
		var plates = [];
		var plane, poleBlack, poleGray, poleWihte, plate1, plate2, plate3, guiControls;
		
		var plateHeight, poleHeight, poleTop, poleBottom;
		
		// load
		var loader = new THREE.ObjectLoader();
		loader.load('model/hanoi-scene.json', function(result) {
			console.log(result);
			scene = result;
			result.children.forEach(function (obj) {
				// console.log(obj);
			});
			
			plane = result.children[0];
			poleBlack = result.children[1];
			poleGray = result.children[2];
			poleWihte = result.children[3];
			plate3 = result.children[4];
			plate2 = result.children[5];
			plate1 = result.children[6];
			light = result.children[7];
			
			init();
			animate();
		});

		function init() {
			camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);
			camera.position.set(371, 363, 350);

			// renderer
			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setClearColor(0xeeeeee);
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.shadowMap.enabled = true;
			renderer.shadowMapSoft = true;

			var container = document.getElementById('main');
			container.appendChild(renderer.domElement);

			// AmbientLight
			scene.add(new THREE.AmbientLight(0x404040));
			
			// init objects
			var box = new THREE.Box3().setFromObject(plane);
			console.log(box.max, box.min, box.size());
			var x = plane.position.x;
			var y = plane.position.y;
			var z = plane.position.z;
			var xl = box.size().x;
			var yl = box.size().y;
			var zl = box.size().z;
			
			box = new THREE.Box3().setFromObject(poleBlack);
			poleHeight = box.size().y;
			
			// set poles' position
			poleBlack.position.set(x, y+yl/2+poleHeight/2,  z+zl/3);
			poleGray.position.set(x, y+yl/2+poleHeight/2,  z);
			poleWihte.position.set(x, y+yl/2+poleHeight/2,  z-zl/3);
			
			poleTop = poleBlack.position.y + poleHeight/2;
			poleBottom = poleBlack.position.y - poleHeight/2;
			poleBlackPos = poleBlack.position.z;
			poleGrayPos = poleGray.position.z;
			poleWihtePos = poleWihte.position.z;
			
			box = new THREE.Box3().setFromObject(plate3);
			plateHeight = box.size().y;
			
			poles.push(poleBlack);
			poles.push(poleGray);
			poles.push(poleWihte);
			
			// set plates' position
			plate3.position.set(poleBlack.position.x, poleBottom+plateHeight/2, poleBlack.position.z);
			plate2.position.set(poleGray.position.x, poleBottom+plateHeight/2, poleGray.position.z);
			plate1.position.set(poleWihte.position.x, poleBottom+plateHeight/2, poleWihte.position.z);
			
			plates.push(plate1);
			plates.push(plate2);
			plates.push(plate3);
			
			poleBlack.arr = [];
			poleBlack.arr.push(plate3);
			poleGray.arr = [];
			poleGray.arr.push(plate2);
			poleWihte.arr = [];
			poleWihte.arr.push(plate1);
			
			steps.push({ which: 1, to: 0 });
			steps.push({ which: 0, to: 0 });
			steps.push({ which: 1, to: 2 });
			steps.push({ which: 1, to: 1 });
			steps.push({ which: 0, to: 1 });
			steps.push({ which: 2, to: 2 });
			steps.push({ which: 0, to: 0 });
			steps.push({ which: 1, to: 2 });
			steps.push({ which: 0, to: 2 });

			// gui controls
			guiControls = new function () {
				this.velocity = v;	
			};
			var datGUI = new dat.GUI();
			datGUI.add(guiControls, 'velocity', 1, 50);

			// controls
			controls = new THREE.OrbitControls(camera, renderer.domElement);
			controls.enableDamping = true;
			controls.dampingFactor = 0.25;
			controls.enableZoom = true;

			// stats
			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			stats.domElement.style.zIndex = 100;
			container.appendChild(stats.domElement);

			window.addEventListener('resize', onWindowResize, false);
		}
		
		function movePlate(plateId, poleId) {
			var plate = plates[plateId];
			var pole = poles[poleId];
			if (plate.stat != 'trans' && pole.arr.indexOf(plate) == -1) {
				plate.position.y += guiControls.velocity;
				if (plate.position.y >= poleTop + plateHeight / 2) {
					plate.position.y = poleTop + plateHeight / 2;
					plate.stat = 'trans';
					removePlateFromPole(plate);
				}
			} else if (plate.stat == 'trans') {
				plate.position.z += pole.position.z > plate.position.z ? guiControls.velocity : -guiControls.velocity;
				if (Math.abs(plate.position.z-pole.position.z) <= guiControls.velocity) {
					plate.position.z = pole.position.z;
					plate.stat = 'fall';
					pole.arr.push(plate);
				}
			} else if (plate.stat == 'fall') {
				plate.position.y -= guiControls.velocity;
				if (plate.position.y <= poleBottom + plateHeight*(pole.arr.length - .5)) {
					plate.position.y = poleBottom + plateHeight*(pole.arr.length - .5);
					delete plate.stat;
					steps.splice(0, 1);
				}
			}
		}
		
		function removePlateFromPole(plate) {
			for (var i in poles) {
				if (poles[i].arr.indexOf(plate) != -1) {
					poles[i].arr.splice(poles[i].arr.indexOf(plate), 1);
					return;
				}
			}
		}

		function animate() {
			requestAnimationFrame(animate);
			
			if (steps.length != 0) {
				movePlate(steps[0].which, steps[0].to);
			}
			
			// console.log(poleBlack.arr.length, poleGray.arr.length, poleWihte.arr.length);

			controls.update();
			stats.update();

			renderer.render(scene, camera);
		}

		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);
		}

		function accurate() {
			//加法
    		Number.prototype.add = function(arg){
     		   var r1,r2,m;
   		     	try{r1=this.toString().split(".")[1].length}catch(e){r1=0}
        		try{r2=arg.toString().split(".")[1].length}catch(e){r2=0}
        		m=Math.pow(10,Math.max(r1,r2))
        		return (this*m+arg*m)/m
    		}
   			//减法
			Number.prototype.sub = function (arg){
				return this.add(-arg);
			}

			//乘法
			Number.prototype.mul = function (arg)
			{
				var m=0,s1=this.toString(),s2=arg.toString();
				try{m+=s1.split(".")[1].length}catch(e){}
				try{m+=s2.split(".")[1].length}catch(e){}
				return Number(s1.replace(".",""))*Number(s2.replace(".",""))/Math.pow(10,m)
			}

			//除法
			Number.prototype.div = function (arg){
				var t1=0,t2=0,r1,r2;
				try{t1=this.toString().split(".")[1].length}catch(e){}
				try{t2=arg.toString().split(".")[1].length}catch(e){}
				with(Math){
					r1=Number(this.toString().replace(".",""))
					r2=Number(arg.toString().replace(".",""))
					return (r1/r2)*pow(10,t2-t1);
				}
			}
		}
	</script>
</body>

</html>