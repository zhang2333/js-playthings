<!DOCTYPE html>
<html>

<head>
	<meta charset="UTF-8">
	<title>hanoi</title>
	<style>
		#main {
			width: 100%;
			margin: 0px;
			padding: 0px;
			overflow: hidden;
		}
	</style>
</head>

<body>
	<div id="main"></div>

	<script type="text/javascript" src="js/three.min.js"></script>
	<script type="text/javascript" src="js/stats.min.js"></script>
	<script type="text/javascript" src="js/dat.gui.min.js"></script>
	<script type="text/javascript" src="js/OrbitControls.js"></script>
	<script type="text/javascript" src="js/Detector.js"></script>

	<script>
		if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
		
		var scene, camera, renderer, stats, controls;
		var lightm, mouse, raycaster, intersected, selected;
		
		var manualMove = {};
		var v = 10;
		var steps = [];
		var poles = [];
		var plates = [];
		var plane, poleBlack, poleGray, poleWihte, plate1, plate2, plate3, guiControls;
		
		var plateHeight, poleHeight, poleTop, poleBottom;
		
		// load
		var loader = new THREE.ObjectLoader();
		loader.load('model/hanoi-scene.json', function(result) {
			console.log(result);
			scene = result;
			result.children.forEach(function (obj) {
				// console.log(obj);
			});
			
			plane = result.children[0];
			poleBlack = result.children[1];
			poleGray = result.children[2];
			poleWihte = result.children[3];
			plate3 = result.children[4];
			plate2 = result.children[5];
			plate1 = result.children[6];
			light = result.children[7];
			
			init();
			animate();
		});

		function init() {
			camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);
			camera.position.set(371, 363, 350);

			// renderer
			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setClearColor(0xeeeeee);
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.shadowMap.enabled = true;
			renderer.shadowMapSoft = true;

			var container = document.getElementById('main');
			container.appendChild(renderer.domElement);

			// AmbientLight
			scene.add(new THREE.AmbientLight(0x404040));
			
			// init objects
			var box = new THREE.Box3().setFromObject(plane);
			console.log(box.max, box.min, box.size());
			var x = plane.position.x;
			var y = plane.position.y;
			var z = plane.position.z;
			var yl = box.size().y;
			var zl = box.size().z;
			
			box = new THREE.Box3().setFromObject(poleBlack);
			poleHeight = box.size().y;
			
			// set poles' position
			poleBlack.position.set(x, y+yl/2+poleHeight/2,  z+zl/3);
			poleGray.position.set(x, y+yl/2+poleHeight/2,  z);
			poleWihte.position.set(x, y+yl/2+poleHeight/2,  z-zl/3);
			
			poleTop = poleBlack.position.y + poleHeight/2;
			poleBottom = poleBlack.position.y - poleHeight/2;
			poleBlackPos = poleBlack.position.z;
			poleGrayPos = poleGray.position.z;
			poleWihtePos = poleWihte.position.z;
			
			box = new THREE.Box3().setFromObject(plate3);
			plateHeight = box.size().y;
			
			poles.push(poleBlack);
			poles.push(poleGray);
			poles.push(poleWihte);
			
			// set plates' position
			plate3.position.set(poleBlack.position.x, poleBottom+plateHeight/2, poleBlack.position.z);
			plate2.position.set(poleGray.position.x, poleBottom+plateHeight/2, poleGray.position.z);
			plate1.position.set(poleWihte.position.x, poleBottom+plateHeight/2, poleWihte.position.z);
			
			plates.push(plate1);
			plates.push(plate2);
			plates.push(plate3);
			
			poleBlack.arr = [];
			poleBlack.arr.push(plate3);
			poleGray.arr = [];
			poleGray.arr.push(plate2);
			poleWihte.arr = [];
			poleWihte.arr.push(plate1);
			
			steps.push({ which: 1, to: 0 });
			steps.push({ which: 0, to: 0 });
			steps.push({ which: 0, to: 2 });
			steps.push({ which: 1, to: 1 });
			steps.push({ which: 0, to: 1 });
			steps.push({ which: 2, to: 2 });
			steps.push({ which: 0, to: 0 });
			steps.push({ which: 1, to: 2 });
			steps.push({ which: 0, to: 2 });

			// gui controls
			guiControls = new function () {
				this.velocity = v;
				this.auto = true;
				this.restart = function restart() {
					selected = null;
					intersected = null;
					manualMove = {};
					for (var i in poles) {
						poles[i].arr = [];
					}
					placePlate(2, 0);
					placePlate(1, 0);
					placePlate(0, 0);
					steps = [];
					steps.push({ which: 0, to: 2 });
					steps.push({ which: 1, to: 1 });
					steps.push({ which: 0, to: 1 });
					steps.push({ which: 2, to: 2 });
					steps.push({ which: 0, to: 0 });
					steps.push({ which: 1, to: 2 });
					steps.push({ which: 0, to: 2 });
				};
			};
			var datGUI = new dat.GUI();
			datGUI.add(guiControls, 'auto');
			datGUI.add(guiControls, 'velocity', 1, 50);
			datGUI.add(guiControls, 'restart');
			
			raycaster = new THREE.Raycaster();
			mouse = new THREE.Vector2();

			// controls
			controls = new THREE.OrbitControls(camera, renderer.domElement);
			controls.enableDamping = true;
			controls.dampingFactor = 0.25;
			controls.enableZoom = true;

			// stats
			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			stats.domElement.style.zIndex = 100;
			container.appendChild(stats.domElement);

			document.addEventListener('mousemove', onMouseMove, false);
			document.addEventListener('click', onClick, false);
			window.addEventListener('resize', onWindowResize, false);
		}
		
		function placePlate(plateId, poleId) {
			var plate = plates[plateId];
			var pole = poles[poleId];
			if (plate.stat) {
				delete plate.stat;
			}
			plate.position.z = pole.position.z;
			pole.arr.push(plate);
			plate.position.y = poleBottom + plateHeight*(pole.arr.length - .5);
		}
		
		function movePlate(plateId, poleId) {
			var plate = typeof(plateId) == 'object' ? plateId : plates[plateId];
			var pole = typeof(poleId) == 'object' ? poleId : poles[poleId];
			// start to rise
			if (plate.stat != 'trans' && pole.arr.indexOf(plate) == -1) {
				plate.position.y += guiControls.velocity;
				if (plate.position.y >= poleTop + plateHeight / 2) {
					plate.position.y = poleTop + plateHeight / 2;
					plate.stat = 'trans';
					operatePlateFromPole(plate, true);
				}
			} else if (plate.stat == 'trans') {
				plate.position.z += pole.position.z > plate.position.z ? guiControls.velocity : -guiControls.velocity;
				if (Math.abs(plate.position.z-pole.position.z) <= guiControls.velocity) {
					plate.position.z = pole.position.z;
					plate.stat = 'fall';
					pole.arr.push(plate);
				}
			} else if (plate.stat == 'fall') {
				plate.position.y -= guiControls.velocity;
				if (plate.position.y <= poleBottom + plateHeight*(pole.arr.length - .5)) {
					plate.position.y = poleBottom + plateHeight*(pole.arr.length - .5);
					delete plate.stat;
					if (manualMove.which) {
						delete manualMove.which;
						delete manualMove.to;
					} else {
						steps.splice(0, 1);
					}
				}
			}
		}
		
		function operatePlateFromPole(plate, remove) {
			for (var i in poles) {
				if (poles[i].arr.indexOf(plate) != -1) {
					if (remove == true) {
						poles[i].arr.splice(poles[i].arr.indexOf(plate), 1);
						return i;
					} else {
						return i;
					}
				}
			}
			return -1;
		}

		function animate() {
			requestAnimationFrame(animate);
			
			if (guiControls.auto) {
				if (steps.length != 0) {
					movePlate(steps[0].which, steps[0].to);
				} else {
					guiControls.restart();
				}
			} else {
				if (manualMove.which) {
					movePlate(manualMove.which, manualMove.to);
				}
			}
			
			// console.log(poleBlack.arr.length, poleGray.arr.length, poleWihte.arr.length);
			
			controls.update();
			stats.update();

			renderer.render(scene, camera);
		}
		
		function onMouseMove(event) {
			event.preventDefault();
			
			mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
			mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
			
			raycaster.setFromCamera( mouse, camera );
			var targets = selected ? poles : plates;
			var intersects = raycaster.intersectObjects(targets);
			if (intersects.length > 0) {
				if ( intersected != intersects[0].object ) {
					if ( intersected ) {
						intersected.material.emissive.setHex( intersected.currentHex );
					}
					intersected = intersects[0].object;
					// only the topest plate can be selected
					if (!selected) {
						var poleId = operatePlateFromPole(intersects[0].object, false);
						if (poleId != -1) {
							intersected = poles[poleId].arr[poles[poleId].arr.length - 1];
						}
					}
					intersected.currentHex = intersected.material.emissive.getHex();
					intersected.material.emissive.setHex( 0x555555 );
				}
			} else {
				if ( intersected ) {
					intersected.material.emissive.setHex( intersected.currentHex );
				}
				intersected = null;
			}
			
		}
		
		function onClick(event) {
			event.preventDefault();
			
			var targets = selected ? poles : plates;
			var intersects = raycaster.intersectObjects(targets);
			if (intersects.length > 0) {
				if ( intersected == intersects[0].object ) {
					if (selected) {
						manualMove.which = selected;
						manualMove.to = intersected;
						selected.material.emissive.setHex( 0x000 );
						intersected.material.emissive.setHex( 0x000 );
						selected = intersected = null;
					} else {
						selected = intersected;
						selected.material.emissive.setHex( 0xff5555 );
						intersected = null;
					}
				}
			} else {
				if ( selected ) {
					selected.material.emissive.setHex( 0x000 );
				}
				selected = null;
			}
		}
		
		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);
		}
	</script>
</body>

</html>