<!DOCTYPE html>
<html>

<head>
	<meta charset="UTF-8">
	<title>hanoi</title>
	<style>
		#main {
			width: 100%;
			margin: 0px;
			padding: 0px;
			overflow: hidden;
		}
	</style>
</head>

<body>
	<div id="main"></div>

	<script type="text/javascript" src="js/three.min.js"></script>
	<script type="text/javascript" src="js/stats.min.js"></script>
	<script type="text/javascript" src="js/dat.gui.min.js"></script>
	<script type="text/javascript" src="js/OrbitControls.js"></script>
	<script type="text/javascript" src="js/Detector.js"></script>

	<script>
		if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
		
		accurate();
		var scene, camera, renderer, stats, controls;
		var light;
		
		var v = 10;
		var steps = [];
		var plane, pole1, pole2, pole3, plate1, plate2, plate3, guiControls;
		
		var plateHeight, poleHeight, poleTop, poleBottom;
		
		// load
		var loader = new THREE.ObjectLoader();
		loader.load('data/hanoi-scene.json', function(result) {
			console.log(result);
			scene = result;
			result.children.forEach(function (obj) {
				// console.log(obj);
			});
			
			plane = result.children[0];
			pole1 = result.children[1];
			pole2 = result.children[2];
			pole3 = result.children[3];
			plate3 = result.children[4];
			plate2 = result.children[5];
			plate1 = result.children[6];
			light = result.children[7];
			
			init();
			animate();
		});

		function init() {
			camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);
			camera.position.set(371, 363, 350);

			// renderer
			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setClearColor(0xeeeeee);
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.shadowMap.enabled = true;
			renderer.shadowMapSoft = true;

			var container = document.getElementById('main');
			container.appendChild(renderer.domElement);

			// AmbientLight
			scene.add(new THREE.AmbientLight(0x404040));
			
			// init objects
			var box = new THREE.Box3().setFromObject(plane);
			console.log(box.max, box.min, box.size());
			var x = plane.position.x;
			var y = plane.position.y;
			var z = plane.position.z;
			var xl = box.size().x;
			var yl = box.size().y;
			var zl = box.size().z;
			
			box = new THREE.Box3().setFromObject(pole1);
			poleHeight = box.size().y;
			
			// set poles' position
			pole1.position.set(x, y+yl/2+poleHeight/2,  z+zl/3);
			pole2.position.set(x, y+yl/2+poleHeight/2,  z);
			pole3.position.set(x, y+yl/2+poleHeight/2,  z-zl/3);
			
			poleTop = pole1.position.y + poleHeight/2;
			poleBottom = pole1.position.y - poleHeight/2;
			pole1Pos = pole1.position.z;
			pole2Pos = pole2.position.z;
			pole3Pos = pole3.position.z;
			
			box = new THREE.Box3().setFromObject(plate3);
			plateHeight = box.size().y;
			
			// set plates' position
			plate3.position.set(pole1.position.x, poleBottom+plateHeight/2, pole1.position.z);
			plate2.position.set(pole2.position.x, poleBottom+plateHeight/2, pole2.position.z);
			plate1.position.set(pole3.position.x, poleBottom+plateHeight/2, pole3.position.z);
			
			pole1.arr = [];
			pole1.arr.push(plate3);
			pole2.arr = [];
			pole2.arr.push(plate2);
			pole3.arr = [];
			pole3.arr.push(plate1);
			
			steps.push({ plate: plate2, pole: pole1 });
			steps.push({ plate: plate1, pole: pole1 });
			steps.push({ plate: plate1, pole: pole3 });
			steps.push({ plate: plate2, pole: pole2 });
			steps.push({ plate: plate1, pole: pole2 });
			steps.push({ plate: plate3, pole: pole3 });
			steps.push({ plate: plate1, pole: pole1 });
			steps.push({ plate: plate2, pole: pole3 });
			steps.push({ plate: plate1, pole: pole3 });

			// gui controls


			// controls
			controls = new THREE.OrbitControls(camera, renderer.domElement);
			controls.enableDamping = true;
			controls.dampingFactor = 0.25;
			controls.enableZoom = true;

			// stats
			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			stats.domElement.style.zIndex = 100;
			container.appendChild(stats.domElement);

			window.addEventListener('resize', onWindowResize, false);
		}
		
		function movePlate(plate, pole) {
			if (plate.stat != 'trans' && pole.arr.indexOf(plate) == -1) {
				plate.position.y += v;
				if (plate.position.y >= poleTop + plateHeight / 2) {
					plate.position.y = poleTop + plateHeight / 2;
					plate.stat = 'trans';
					removePlate(plate);
				}
			} else if (plate.stat == 'trans') {
				plate.position.z += pole.position.z > plate.position.z ? v : -v;
				if (Math.abs(plate.position.z-pole.position.z) <= v) {
					plate.position.z = pole.position.z;
					plate.stat = 'fall';
					pole.arr.push(plate);
				}
			} else if (plate.stat == 'fall') {
				plate.position.y -= v;
				if (plate.position.y <= poleBottom + plateHeight*(pole.arr.length - .5)) {
					plate.position.y = poleBottom + plateHeight*(pole.arr.length - .5);
					delete plate.stat;
					steps.splice(0, 1);
				}
			}
		}
		
		function removePlate(plate) {
			if (pole1.arr.indexOf(plate) != -1) {
				pole1.arr.splice(pole1.arr.indexOf(plate), 1);
			} else if (pole2.arr.indexOf(plate) != -1) {
				pole2.arr.splice(pole2.arr.indexOf(plate), 1);
			} else if (pole3.arr.indexOf(plate) != -1) {
				pole3.arr.splice(pole3.arr.indexOf(plate), 1);
			}
		}

		function animate() {
			requestAnimationFrame(animate);
			
			if (steps.length != 0) {
				movePlate(steps[0].plate, steps[0].pole);
			}
			
			// console.log(pole1.arr.length, pole2.arr.length, pole3.arr.length);

			controls.update();
			stats.update();

			renderer.render(scene, camera);
		}

		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);
		}

		function accurate() {
			//加法
    		Number.prototype.add = function(arg){
     		   var r1,r2,m;
   		     	try{r1=this.toString().split(".")[1].length}catch(e){r1=0}
        		try{r2=arg.toString().split(".")[1].length}catch(e){r2=0}
        		m=Math.pow(10,Math.max(r1,r2))
        		return (this*m+arg*m)/m
    		}
   			//减法
			Number.prototype.sub = function (arg){
				return this.add(-arg);
			}

			//乘法
			Number.prototype.mul = function (arg)
			{
				var m=0,s1=this.toString(),s2=arg.toString();
				try{m+=s1.split(".")[1].length}catch(e){}
				try{m+=s2.split(".")[1].length}catch(e){}
				return Number(s1.replace(".",""))*Number(s2.replace(".",""))/Math.pow(10,m)
			}

			//除法
			Number.prototype.div = function (arg){
				var t1=0,t2=0,r1,r2;
				try{t1=this.toString().split(".")[1].length}catch(e){}
				try{t2=arg.toString().split(".")[1].length}catch(e){}
				with(Math){
					r1=Number(this.toString().replace(".",""))
					r2=Number(arg.toString().replace(".",""))
					return (r1/r2)*pow(10,t2-t1);
				}
			}
		}
	</script>
</body>

</html>