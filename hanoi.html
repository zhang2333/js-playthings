<!DOCTYPE html>
<html>

<head>
	<meta charset="UTF-8">
	<title>hanoi</title>
	<style>
		#main {
			width: 100%;
			margin: 0px;
			padding: 0px;
			overflow: hidden;
		}
	</style>
</head>

<body>
	<div id="main"></div>

	<script type="text/javascript" src="js/three.min.js"></script>
	<script type="text/javascript" src="js/stats.min.js"></script>
	<script type="text/javascript" src="js/dat.gui.min.js"></script>
	<script type="text/javascript" src="js/OrbitControls.js"></script>
	<script type="text/javascript" src="js/Detector.js"></script>

	<script>
		if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
		
		var CAMERA_ROTATION = (.01/180*Math.PI);
		
		var scene, camera, renderer, stats, controls;
		var light, mouse, raycaster, intersected, selected;
		
		var v = 10;
		var manualMove = {};
		var steps = [];
		var stepsCache = [];
		var poles = [];
		var plates = [];
		var plane, poleBlack, poleGray, poleWihte, plate, guiControls;
		
		var plateHeight, poleHeight, poleTop, poleBottom;
		
		var planeDefScale = {};
		var poleDefScaleY;
		
		// load
		var loader = new THREE.ObjectLoader();
		loader.load('model/hanoi-scene.json', function(result) {
			console.log(result);
			scene = result;
			result.children.forEach(function (obj) {
				// console.log(obj);
			});
			
			plane = result.children[0];
			poleBlack = result.children[1];
			poleGray = result.children[2];
			poleWihte = result.children[3];
			plate = result.children[4];
			light = result.children[5];
			
			planeDefScale.x = plane.scale.x;
			planeDefScale.y = plane.scale.y;
			planeDefScale.z = plane.scale.z;
			poleDefScaleY = poleWihte.scale.y;
			poles.push(poleBlack);
			poles.push(poleGray);
			poles.push(poleWihte);
			plate.weight = 1;
			scene.remove(plate);
			
			init();
			animate();
		});

		function init() {
			camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 100000);
			camera.position.set(350, 363, 350);

			// renderer
			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setClearColor(0xffffff);
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.shadowMap.enabled = true;
			renderer.shadowMapSoft = true;

			var container = document.getElementById('main');
			container.appendChild(renderer.domElement);

			// AmbientLight
			scene.add(new THREE.AmbientLight(0x909090));
			
			// gui controls
			guiControls = new function () {
				this.velocity = v;
				this.auto = true;
				this.plates= 5;
				this.rotateSpeed = 0;
				this.resetCamera = function resetCamera() {
					camera.position.set(poleHeight*4+50, poleHeight*4+50, 50);
				};
				this.restart = restart;
			};
			var datGUI = new dat.GUI();
			datGUI.add(guiControls, 'auto');
			datGUI.add(guiControls, 'plates', 1, 50).step(1);
			datGUI.add(guiControls, 'velocity', 1, 50);
			datGUI.add(guiControls, 'rotateSpeed', 0, 100);
			datGUI.add(guiControls, 'resetCamera');
			datGUI.add(guiControls, 'restart');
			
			// plate interaction
			raycaster = new THREE.Raycaster();
			mouse = new THREE.Vector2();

			// controls
			controls = new THREE.OrbitControls(camera, renderer.domElement);
			controls.enableDamping = true;
			controls.dampingFactor = 0.25;
			controls.enableZoom = true;

			// stats
			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			stats.domElement.style.zIndex = 100;
			container.appendChild(stats.domElement);

			document.addEventListener('mousemove', onMouseMove, false);
			document.addEventListener('click', onClick, false);
			window.addEventListener('resize', onWindowResize, false);
			
			// init starting
			restart();
		}
		
		// start or restart
		function restart() {
			camera.position.set(350, 363, 350);
			selected = null;
			intersected = null;
			manualMove = {};
			// clear plates
			for (var i in plates) {
				scene.remove(plates[i]);
			}
			plates = [];
			// add plates
			for(var i = 0; i <= guiControls.plates - 1; i++) {
				var p = new THREE.Mesh(plate.geometry.clone(), plate.material.clone());
				p.scale.set(plate.scale.x*(1+(.2*i)), plate.scale.y, plate.scale.z*(1+(.2*i)));
				p.material.color = new THREE.Color(randomColorHex());
				p.weight = i + 1;
				plates.push(p);
				scene.add(p);
			}
			// init plane
			plane.scale.x = planeDefScale.x;
			plane.scale.z = planeDefScale.z;
			
			// init poles
			for (var i in poles) {
				poles[i].scale.y = poleDefScaleY;
			}
			// expand plane, poles
			var box = new THREE.Box3().setFromObject(plane);
			if (guiControls.plates > 4) {
				// expand plane
				var plateWidth = new THREE.Box3().setFromObject(plates[plates.length-1]).size().x;
				var scale = .1;
				while(box.size().z < 3 * plateWidth) {
					plane.scale.x = planeDefScale.x * (scale +1);
					plane.scale.z = planeDefScale.z * (scale +1);
					scale += .1;
					box.setFromObject(plane);
				}
				
				// expand poles
				if (guiControls.plates > 10) {
					for (var i in poles) {
						poles[i].scale.y = poleDefScaleY * ((guiControls.plates - 10)*.1 + 1);
					}
				}
			}
			// reset poles
			box.setFromObject(plane);
			var x = plane.position.x;
			var y = plane.position.y;
			var z = plane.position.z;
			var yl = box.size().y;
			var zl = box.size().z;
			
			box.setFromObject(poleBlack);
			poleHeight = box.size().y;
			
			// set poles' position
			poleBlack.position.set(x, y+yl/2+poleHeight/2,  z+zl/3);
			poleGray.position.set(x, y+yl/2+poleHeight/2,  z);
			poleWihte.position.set(x, y+yl/2+poleHeight/2,  z-zl/3);
			poleTop = poleBlack.position.y + poleHeight/2;
			poleBottom = poleBlack.position.y - poleHeight/2;
			
			box.setFromObject(plate);
			plateHeight = box.size().y;
			
			guiControls.resetCamera();
			
			resetPlates();
			steps = [];
			stepsCache = [];
			computeSteps();
		}
		
		// compute steps and set into stepCache
		function computeSteps() {
			// TODO: optimize
			if (poleBlack.arr.length <= 15) {
				var plateArr = poleBlack.arr.reverse();
				var froms = [];
				for (var p in plateArr) {
					plateArr[p] = plates.indexOf(plateArr[p]);
					froms[p] = 0;
				}
				stepsCache = stepsCache.concat(move(plateArr, 2, [], froms));
			}
		}

		function move(whichIds, to, arr, froms) {
			// simplest move if it's true
			if (whichIds.length == 1) {
				froms[whichIds[0]] = to;
				arr.push({ which: whichIds[0], to: to });
			} else {
				var last = whichIds[whichIds.length-1];
				// get idle pole
				var a = [0, 1, 2];
				a.splice(a.indexOf(to), 1);
				a.splice(a.indexOf(froms[last]), 1);
				var idlePole = a[0];
				
				// 1. move upper plates
				move(whichIds.slice(0, whichIds.length-1), idlePole, arr, froms);
				
				// 2. move the last plate to target
				move([last], to, arr, froms);
				
				// 3. return upper plates
				move(whichIds.slice(0, whichIds.length-1), to, arr, froms);
			}
			
			return arr;
		}
		
		// reset position of plates
		function resetPlates() {
			for (var i in poles) {
				poles[i].arr = [];
			}
			for (var ii = plates.length-1; ii >= 0; ii--) {
				placePlate(ii, 0);
			}
		}
		
		function placePlate(plateId, poleId) {
			var plate = plates[plateId];
			var pole = poles[poleId];
			if (plate.stat) {
				delete plate.stat;
			}
			plate.position.z = pole.position.z;
			pole.arr.push(plate);
			plate.position.y = poleBottom + plateHeight*(pole.arr.length - .5);
		}
		
		function movePlate(plateId, poleId) {
			var plate = typeof(plateId) == 'object' ? plateId : plates[plateId];
			var pole = typeof(poleId) == 'object' ? poleId : poles[poleId];
			// big one can't place over the smaller one
			var f1 = pole.arr.length > 0 && pole.arr[pole.arr.length-1].weight < plate.weight;
			// invalid operation
			var f2 = pole.arr.indexOf(plate) != -1 && !plate.stat;
			if (f1 || f2) {
				if (manualMove.which) {
					delete manualMove.which;
					delete manualMove.to;
				}
				return;
			}
			// rise or trans or fall
			if (plate.stat == 'trans') {
				plate.position.z += pole.position.z > plate.position.z ? guiControls.velocity : -guiControls.velocity;
				if (Math.abs(plate.position.z-pole.position.z) <= guiControls.velocity) {
					plate.position.z = pole.position.z;
					plate.stat = 'fall';
					pole.arr.push(plate);
				}
			} else if (plate.stat == 'fall') {
				plate.position.y -= guiControls.velocity;
				if (plate.position.y <= poleBottom + plateHeight*(pole.arr.length - .5)) {
					plate.position.y = poleBottom + plateHeight*(pole.arr.length - .5);
					delete plate.stat;
					if (manualMove.which) {
						delete manualMove.which;
						delete manualMove.to;
					} else {
						steps.splice(0, 1);
					}
				}
			} else {
				plate.position.y += guiControls.velocity;
				if (plate.position.y >= poleTop + plateHeight / 2) {
					plate.position.y = poleTop + plateHeight / 2;
					plate.stat = 'trans';
					operatePlateFromPole(plate, true);
				}
			}
		}
		
		function operatePlateFromPole(plate, remove) {
			for (var i in poles) {
				if (poles[i].arr.indexOf(plate) != -1) {
					if (remove == true) {
						poles[i].arr.splice(poles[i].arr.indexOf(plate), 1);
					}
					return parseInt(i);
				}
			}
			return -1;
		}

		function animate() {
			requestAnimationFrame(animate);
			
			if (guiControls.auto) {
				if (steps.length != 0) {
					movePlate(steps[0].which, steps[0].to);
				} else {
					resetPlates();
					steps = steps.concat(stepsCache);
				}
			} else {
				if (manualMove.which) {
					movePlate(manualMove.which, manualMove.to);
				}
			}
			
			// move over plates
			raycaster.setFromCamera( mouse, camera );
			var intersects = raycaster.intersectObjects(selected ? poles : plates);
			if (intersects.length > 0) {
				if ( intersected != intersects[0].object ) {
					intersected = intersects[0].object;
					// only the topest plate can be selected
					if (!selected) {
						var poleId = operatePlateFromPole(intersects[0].object, false);
						if (poleId != -1) {
							intersected = poles[poleId].arr[poles[poleId].arr.length - 1];
						}
					}
					intersected.material.emissive.setHex( 0x555555 );
				}
			} else {
				if ( intersected ) {
					intersected.material.emissive.setHex( 0x000 );
					intersected = null;
				}
			}
			
			// rotate camera
			var radius = Math.sqrt(camera.position.x*camera.position.x + camera.position.z*camera.position.z);
			if (guiControls.rotateSpeed != 0) {
				var z = camera.position.z;
				camera.position.z = camera.position.z*Math.cos(guiControls.rotateSpeed*CAMERA_ROTATION)
										+camera.position.x*Math.sin(guiControls.rotateSpeed*CAMERA_ROTATION);
				var x = Math.sqrt(radius*radius - camera.position.z*camera.position.z);
				camera.position.x = camera.position.z - z >= 0 ? x : -x;
			}
			
			
			controls.update();
			stats.update();

			renderer.render(scene, camera);
		}
		
		function onClick(event) {
			event.preventDefault();
			
			if (guiControls.auto) {
				return;
			}
			
			var targets = selected ? poles : plates;
			var intersects = raycaster.intersectObjects(targets);
			if (intersects.length > 0 && !manualMove.to) {
				var newId = operatePlateFromPole(intersects[0].object, false);
				var intersectedId = operatePlateFromPole(intersected, false);
				if ( newId == intersectedId ) {
					if (selected) {
						manualMove.which = selected;
						manualMove.to = intersected;
						selected.material.emissive.setHex( 0x000 );
						intersected.material.emissive.setHex( 0x000 );
						selected = intersected = null;
					} else {
						selected = intersected;
						selected.material.emissive.setHex( 0xff5555 );
						intersected = null;
					}
				}
			} else {
				if ( selected ) {
					selected.material.emissive.setHex( 0x000 );
				}
				selected = null;
			}
		}
		
		function onMouseMove(event) {
			event.preventDefault();
			
			mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
			mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
			
		}
		
		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);
		}
		
		function randomColorHex() {
			return '#'+('00000'+(Math.random()*0x1000000<<0).toString(16)).slice(-6);
		}
	</script>
</body>

</html>